完全透明的情况 我们就给他丢弃就行了

```c++
    vec4 texColor = texture(material.texture_diffuse1,TexCoords);
    if(texColor.a < 0.1) discard;
    FragColor = texColor;
```

混合的情况呢 

使用混和后就没必要丢弃点了

```
 FragColor = texture(material.texture_diffuse1,TexCoords);
```

修改纹理图片

 m_gressTex = new QOpenGLTexture(QImage(":/blending_transparent_window.png"));

但是这会发现 前面的透明部分 挡住了后面的，是因为先绘制了前面的 后绘制的后面的 导致后面的就没有通过深度测试，根本没被绘制出来,顺序应该是先绘制前面的 对所有透明的物体排序，在绘制后面的物体

为什么呢 因为 先绘制后面的 然后绘制后面的 在通过深度测试的同时，进行混合



一个要注意这一点的理解

比如第一次调用了一个物体(传入了一批顶点)，他就已经被绘制在屏幕上了，

然而当你第二次调用另一个物体绘制时,比如物体透明的，也就是需要混合,那么如果他就会与当前已经在屏幕上的物体来进行计算得出最终的颜色,

所以之前的问题是，如果先绘制的是这个透明的物体(这时候由于已经完成的GPU绘制屏幕上已经有了像素),那么再绘制另一个物体的时候,这个物体还没有通过深度测试，那他根本不会被绘制在屏幕上，也就不可能混合了，当然，如果后面绘制的物体可以通过深度测试,但是要注意的是，这时候他通过了深度测试,那么他就是目标颜色了,因为它将被绘制在前面. 那他还是可以混合的，

前面的是目标颜色 如果他的透明度是1 那么我们使用上面的方法 就会得到 1 * 1  + 后面的透明度 *（1-1）的到的是1 那么就会是不透明的了
