## 模型控制理论

- 遍历所有model,拿到model最大高度和最小高度 将距离除以2拿到半径
- 用世界坐标的距离相减获取到点中的距离离和上面为半径的球的距离，如果在里面，表示点中了。
- 修改摄像机位置为固定（取消加载时的重新赋值）

将物体抬高到地面以上

```c++
 m_Models["模型"+QString::number(i++)] = ModelInfo{m_model,QVector3D(0,0 - m_model->m_minY,0) ,0.0,0.0,0.0,false,"模型"};
```

双击选中后移动:其实也可以单击,看个人

创建移动变量：双击进入选中状态 再次双击取消

```
bool          m_modeMoving = false;
```

实现按下事件

```c++
void COpenGlWidget::mousePressEvent(QMouseEvent *event)
{
    makeCurrent();
    if(event->buttons() & Qt::LeftButton)
    {
        QVector4D worldPos = API_worldPosToViewPos(event->pos().x(),event->pos().y());
        emit signal_mousePickingPos(worldPos);

        for(QMap<QString, ModelInfo>::iterator iter=m_Models.begin();iter!=m_Models.end();iter++){
            ModelInfo *modelInfo=&iter.value();
            float r=(modelInfo->mode->m_maxY - modelInfo->mode->m_minY)/2;
            if(modelInfo->worldPos.distanceToPoint(QVector3D(worldPos))<r && m_modeMoving == false)
            {
                modelInfo->isSelected=true;
                break;
            }
            else
            {
                modelInfo->isSelected=false;
            }
        }
    }
    doneCurrent();
}
```



实现双击函数

```c++
void COpenGlWidget::mouseDoubleClickEvent(QMouseEvent *event)
{
    if(m_modeMoving == true)
    {
        m_modeMoving = false;
        return;
    }
    makeCurrent();
    foreach(auto mode,m_Models)
    {
        if(mode.isSelected) m_modeMoving = true;
    }
    doneCurrent();
}

```

实现移动函数

```c++
void COpenGlWidget::mouseMoveEvent(QMouseEvent *event)
{
    if(event->buttons() & Qt::RightButton){
        static QPoint lastPos(width()/2,height()/2);
        auto currentPos=event->pos();
        QPoint deltaPos=currentPos-lastPos;
        lastPos=currentPos;

        m_camera.ProcessMouseMovement(deltaPos.x(),-deltaPos.y());
        update();
    }
    if(!m_modeMoving) return;
    makeCurrent();
    for(auto item:m_Models)
    {
        if(!item.isSelected) continue;
        item.worldPos = QVector3D(API_worldPosToViewPos(event->pos().x(),event->pos().y()));
    }

    doneCurrent();

}
```

遗留的问题: 如果同时选中两个,我们可以通过计算两个模型之间的偏移量来移动，而不是每次一移动两个一直在一起.