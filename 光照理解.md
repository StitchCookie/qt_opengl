## 光照理解

- 尝试使用不同的环境光、漫反射和镜面强度，观察它们怎么是影响光照效果的。同样，尝试实验一下镜面光照的反光度因子。尝试理解为什么某一个值能够有着某一种视觉输出。

1. **环境光（Ambient Light）**：
   - 环境光是无方向性的全局光照，通常用于模拟来自周围环境的间接光照效果。增大环境光的强度会使场景整体变得更亮，降低对比度，所有物体表面都会有基本的光照，不论它们面向哪个方向。环境光强度过大会减弱场景的深度感和细节表现。

1. **漫反射光（Diffuse Light）**：
   - 漫反射光照基于光源方向与物体表面法线之间的角度关系。当光源照射在物体表面时，光线会分散到各个方向，表面的光照效果与光源和表面法线的夹角有关，夹角越小（接近0度），光照越强。增大漫反射光照强度会使受光面显得更亮，同时体现出更多的纹理和形状信息。
2. *镜面光（Specular Light）**：
   - 镜面光照模拟的是光滑表面反射出的高光区域，其强度取决于光源、观察者和表面法线之间的几何关系，通常使用的是 Blinn-Phong 或 Phong 光照模型。镜面光的强度和“反光度”（也称为 shininess 或 glossiness）有关，反光度越高，高光区域越集中、越亮；反之，则高光范围更广但亮度更低。通过调整镜面光照强度，可以控制物体表面高光部分的明亮程度，展现材质的光泽度。

## 在观察空间中计算冯氏光照:

- 顶点着色器

  ```c++
  #version 330 core
  layout(location = 0) in vec3 aPos;
  layout(location = 1) in vec3 aNormal; // 法向量
  uniform mat4 model;
  uniform mat4 view;
  uniform mat4 projection;
  out vec3 Normal;
  out vec3 FragPos; // 顶点的世界坐标位置
  out vec3 LightPos;
  uniform vec3 lightPos; // 光源位置
  void main(){
        gl_Position =  projection * view * model * vec4(aPos, 1.0);
        FragPos = vec3(view * model * vec4(aPos,1.0f));
        // inverse 求逆  transpose求转置
        //在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。
        // 但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。 Normal = mat3(model) * aNormal;
        Normal = mat3(transpose(inverse(view * model))) * aNormal;
        LightPos = vec3(view * vec4(lightPos,1.0));
  }
  ```

  

- 片段着色器

```c++
#version 330 core
out vec4 FragColor;
uniform vec3 objectColor;
uniform vec3  lightColor;
in vec3 Normal;
in vec3 FragPos;
in vec3 LightPos;
uniform vec3 viewPos;  // 摄像机观察位置
void main(){
    // 设置一个常量环境因子
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    // 将法线单位化
    vec3 norm = normalize(Normal);
    // 将光的方向向量单位化
    vec3 lightDir = normalize(LightPos -  FragPos);
    // 只有在小于90度时才会贡献漫反射光照
    float diff = max(dot(norm,lightDir),0.0f);
    // 漫反射光照值
    vec3 diffuse= diff * lightColor;
    float speculatStrength = 0.5;  //镜面强度变量
    vec3 viewDir = normalize(viewPos - FragPos);   // 视角方向向量  摄像机位置向量减去顶点向量
    vec3 reflectDir = reflect(-lightDir,norm);  // 光源反射的方向向量
    // 计算镜面分量 最后，这个部分将余弦值的32次方，这通常用来增强高光部分，使其更加明显。
    // 这样做是为了增强镜面高光的效果，使得夹角越小的区域有更强的高光
    float spec = pow(max(dot(viewDir,reflectDir),0.0),32);
    vec3 specular = speculatStrength * spec * lightColor;
    vec3 result = (ambient + diffuse + specular)* objectColor;
    FragColor = vec4(result,1.0f);
}
```

## 尝试使用Gouraud着色

- 顶点着色器

```c++
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal; // 法向量
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec3 lightColor; // 光源颜色
uniform vec3 lightPos;   // 光源位置
uniform vec3 viewPos;  // 摄像机观察位置
uniform vec3 objectColor; // 物体本源颜色
out vec3 result;

void main(){
    gl_Position =  projection * view * model * vec4(aPos, 1.0);
    // 环境光照
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;  // 环境光照

    // 漫反射光照
    // 第一步计算法线
    vec3 Normal = mat3(transpose(inverse(model))) * aNormal;
    vec3 norm = normalize(Normal);
    // 第二步  拿到顶点的世界坐标去计算光源方向向量
    vec3 FragPos = vec3(model * vec4(aPos,1.0));
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm,lightDir),0.0f);
    // 第三步 获取漫反射光照值
    vec3 diffuse = diff * lightColor;

    // 镜面光照
    // 设置镜面强度变量
    float speclatStrength = 0.5;
    // 获取视角方向向量
    vec3 viewDir = normalize(viewPos - FragPos);
    // 光源反射方向向量
    vec3 reflectDir = reflect(-lightDir,norm);
    // 计算镜面分量
    float spec = pow(max(dot(viewDir,reflectDir),0.0),32);
    // 获取镜面光照值
    vec3 specular = speclatStrength * spec * lightColor;

    // 获取物体反射的颜色（也就是显示在视角的颜色）
    vec3 resultTmp = (ambient + diffuse + specular) * objectColor;
    result = resultTmp;
}

```

- 片段着色器

  ```c++
  #version 330 core
  out vec4 FragColor;
  in vec3 result; // 从顶点着色器计算的片段颜色
  
  void main(){
  
      FragColor = vec4(result,1.0f);
  }
  
  ```

  

## 本篇默认着色器：

```c++
#version 330 core
out vec4 FragColor;
uniform vec3 objectColor;
uniform vec3  lightColor;
uniform vec3 lightPos; // 光源位置
in vec3 Normal;
in vec3 FragPos;

uniform vec3 viewPos;  // 摄像机观察位置
void main(){

    // 设置一个常量环境因子
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // 将法线单位化
    vec3 norm = normalize(Normal);
    // 将光的方向向量单位化
    vec3 lightDir = normalize(lightPos -  FragPos);
    // 只有在小于90度时才会贡献漫反射光照
    float diff = max(dot(norm,lightDir),0.0f);
    // 漫反射光照值
    vec3 diffuse= diff * lightColor;
    float speculatStrength = 0.5;  //镜面强度变量
    vec3 viewDir = normalize(viewPos - FragPos);   // 视角方向向量  摄像机位置向量减去顶点向量
    vec3 reflectDir = reflect(-lightDir,norm);  // 光源反射的方向向量
    // 计算镜面分量 最后，这个部分将余弦值的32次方，这通常用来增强高光部分，使其更加明显。
    // 这样做是为了增强镜面高光的效果，使得夹角越小的区域有更强的高光
    float spec = pow(max(dot(viewDir,reflectDir),0.0),32);
    vec3 specular = speculatStrength * spec * lightColor;
    vec3 result = (ambient + diffuse + specular)* objectColor;
    FragColor = vec4(result,1.0f);
}
// 顶点着色器
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal; // 法向量
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
out vec3 Normal;
out vec3 FragPos; // 顶点的世界坐标位置

void main(){
     gl_Position =  projection * view * model * vec4(aPos, 1.0);
     FragPos = vec3(model * vec4(aPos,1.0f));
     // inverse 求逆  transpose求转置
     //在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。
     // 但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。 Normal = mat3(model) * aNormal;
      Normal = mat3(transpose(inverse(model))) * aNormal;
}

```

注释: 

- 在着色器程序替换过程中 不需要替换默认光源的片段着色器，也就是shapesLighting.frag文件,让其默认就行