## 多光源

对于多光源我们要在GLSL中封装各个光源的计算方式,否则这将会变得很复杂，代码也不容易维护

所以下面的条件就变得很重要了

- 有一个单独的颜色向量代表片段的输出颜色
- 对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上
- 对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上

下面是一个类似的处理过程:

```c++
out vec4 FragColor;
void main()
{
  // 定义一个输出颜色值
  vec3 output;
  // 将定向光的贡献加到输出中
  output += someFunctionToCalculateDirectionalLight();
  // 对所有的点光源也做相同的事情
  for(int i = 0; i < nr_of_point_lights; i++)
    output += someFunctionToCalculatePointLight();
  // 也加上其它的光源（比如聚光）
  output += someFunctionToCalculateSpotLight();
  FragColor = vec4(output, 1.0);
}
```

所以我们的任务是什么呢？

- [x] 我们定义了几个函数，用来计算每个光源的影响，并将最终的结果颜色加到输出颜色向量上

## 定向光

- [x] 这是一个定向光照所需要的属性

```c++
struct DirLight {
    vec3 direction;  // 定向光方向 它不需要强度因为是定向光

    vec3 ambient;   // 定向光的环境光照分量
    vec3 diffuse;   // 定向光的漫反射光照分量
    vec3 specular;  // 定向光的镜面光光照分量
};  
uniform DirLight dirLight;
```

- [x] 接下来将这些参数传入一个API来计算

```c++
vec3 API_calcDirLight(DirLight light, vec3 normal, vec3 viewDir);
```

- 其实与之前的计算方式是完全相同的:传参分别是: 光源属性,法向量,观察向量

  ```c++
  vec3 API_calcDirLight(DirLight light,vec3 normal,vec3 viewDir)
  {
      vec3 lightDir = normalize(-light.direction);
      float diff = max(dot(normal,lightDir),0.0);
      vec3 reflectDir = reflect(-light,normal);
      float spec = pow(max(dot(viewDir,reflectDir),0.0f),material.shininess);
      // 上面是获取对应光照分量的值 下面则要开始计算了
      vec3 ambient = light.ambient * vec3(texture(material.diffuse,TexCoords));
      vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));
      vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
      return (ambient + diffuse + specular);
  }
  ```

## 点光源

- [x] 这是一个点光所需要的属性

  - 我们需要它的三个衰减系数

  - 同样的也需要其他的光照分量属性

    ```c++
    struct PointLight {
        vec3 position;    // 点光源的位置向量
    
        float constant;  // 常量 一般为1
        float linear;    // 线性衰减常量
        float quadratic; // 二次方衰减常量
    
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
    }; 
    #define NR_POINT_LIGHTS 4  //我们设置了4个点光源
    uniform PointLight pointLights[NR_POINT_LIGHTS];
    ```

- [x] 接下来我们需要和定向光一样去设置API

  ```c++
  vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
  ```

  ```c++
  vec3 API_calcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
  {
      vec3 lightDir = normalize(light.position - fragPos);
      float diff = max(dot(normal,lightDir),0.0);
      vec3 reflectDir = reflect(-lightDir,normal);
      float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
  
      // 计算衰减
      float distance = length(light.position - fragPos);
      float attenuation = 1.0 / (light.constant + light.linear * distance +
                                 light.quadratic * (distance * distance));
  
      vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));
      vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));
      vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
      // 衰减
      ambient  *= attenuation;
      diffuse  *= attenuation;
      specular *= attenuation;
      return (ambient + diffuse + specular);
  }
  ```

  

  - 我们能够不用重复的代码而很容易地计算多个点光源的光照了。在main函数中，我们只需要创建一个循环，遍历整个点光源数组，对每个点光源调用CalcPointLight就可以了。

## 聚光源

- [x] 同样的先定义一个聚光源需要的属性

  ```c++
  struct SpotLight {
      vec3 position;
      vec3 direction;
      float cutOff;       // 内切角的cos值
      float outerCutOff;  // 外切角的cos值
    
      float constant;
      float linear;
      float quadratic;
    
      vec3 ambient;
      vec3 diffuse;
      vec3 specular;       
  };
  
  ```

  