聚光：

聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。

聚光必须要知道三个条件

- 世界空间位置
- 方向： 聚光灯所指向的方向
- 切光角： 指定聚光的半径

- [x] 现在我们就要利用点积来计算出片段向量与聚光向量之间的夹角，如果是小于切光角，那麽就会被照亮.

### 手电筒

- 通常来说手电筒都是一个位于观察者位置的聚光灯

- 但值得注意的是,他的位置和方向会随着观察者的位置和朝向不断更新

  - [x] 所以我们需要将聚光的所有属性储存起来

  ```
  struct Light
  {
      vec3 postion;
      vec3 direction;
      float cutoff;
  };
  ```

- [x]  接下来我们需要将对应合适的值传给着色器

  ​         

  ```c++
  float cutOff = static_cast<float>(cos(12.5 / 3.1415926 * 180));     shaderProgramObject.setUniformValue("light.direction",m_camera.m_cameraLookAtFrontDirection);     shaderProgramObject.setUniformValue("light.position",m_camera.m_cameraPos);
          shaderProgramObject.setUniformValue("light.cutOff",cutOff);
  ```

  - 值得注意的是,传递的并不是一个角度,而是余弦值
  - 因为点积的结果是一个余弦值，为了方便比较
  - 如果传入角度,还需要再计算点积后，进行反余弦计算，这会很麻烦，并且耗时

- [x] 接下来就是计算着色器片段与聚光的夹角值,与切光角对比

  

```c++
#version 330 core
struct Material {
    sampler2D diffuse;  // 漫反射贴图
    sampler2D specular;
    float shininess;
};

struct Light {
    vec3 direction;  // 聚光灯方向
    vec3 position;
    float  cutOff;     // 聚光灯切角

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float constant;
    float linear;
    float quadratic;
};

out vec4 FragColor;
in vec3 Normal;
in vec3 FragPos;

uniform Material material;
uniform Light light;
uniform vec3 viewPos;  // 摄像机观察位置
in vec2 TexCoords;  // 纹理坐标


void main(){

    vec3 lightDir = normalize(light.position - FragPos);  // 指向光源的方向向量

    // 取反 则方向向量指向光源   获得顶点与聚光方向的夹角值
    float theta = dot(lightDir,normalize(-light.direction));

    if(theta > light.cutOff)
    {
        // 环境光仍然使用漫反射贴图
        vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;
        // 漫反射
        vec3 norm = normalize(Normal);
        // 计算漫反射夹角
        float diff = max(dot(norm,lightDir),0.0f);
        vec3 diffuse =  light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;
        // 镜面反射
        // 指向视角向量
        vec3 viewDir = normalize(viewPos - FragPos);
        // 反射方向  参数 入射角方向向量  法向量
        vec3 reflectDir = reflect(-lightDir,norm);
        // 镜面反射指数
        float spec = pow(max(dot(viewDir,reflectDir),0.0f),material.shininess);
        // 镜面光照
        vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;

        // 衰减光源
        float distance = length(light.position - FragPos);
        float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

        // 计算衰弱光源
        // 消除环境的衰减，否则在很远的距离处，由于 else 分支中的环境项，聚光灯内部的光会比外部更暗

        //ambient *= attenuation;
        diffuse *= attenuation;
        specular  *= attenuation;
        vec3 result = ambient + diffuse + specular;
        FragColor = vec4(result,0);
    }else
    {
        FragColor = vec4(light.ambient * texture(material.diffuse, TexCoords).rgb, 1.0);
    }
}
```

### 注意:

在之前的混合效果中我们设置了开启混合函数功能的调用,这里最好是不要调用这个函数，或者禁用掉

```
    glDisable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);  // 设置透明度
```

### 平滑/软化边缘

- 为了让聚光灯的范围平滑的过度,我们给聚光灯的外围设置了一个外光切角度,这个外光切的角度会在0-1之间，如果在内光切之内就是1.0如果在外关切之外就是0.0

```
#version 330 core
struct Material {
    sampler2D diffuse;  // 漫反射贴图
    sampler2D specular;
    float shininess;
};

struct Light {
    vec3 direction;  // 聚光灯方向
    vec3 position;
    float  cutOff;     // 聚光灯切角
    float  outerCutOff; // 外光切切角

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float constant;
    float linear;
    float quadratic;
};

out vec4 FragColor;
in vec3 Normal;
in vec3 FragPos;

uniform Material material;
uniform Light light;
uniform vec3 viewPos;  // 摄像机观察位置
in vec2 TexCoords;  // 纹理坐标


void main(){
        // 环境光仍然使用漫反射贴图
        vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;
        // 漫反射
        vec3 norm = normalize(Normal);
        vec3 lightDir = normalize(light.position - FragPos);
        // 计算漫反射夹角
        float diff = max(dot(norm,lightDir),0.0f);
        vec3 diffuse =  light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;
        // 镜面反射
        // 指向视角向量
        vec3 viewDir = normalize(viewPos - FragPos);
        // 反射方向  参数 入射角方向向量  法向量
        vec3 reflectDir = reflect(-lightDir,norm);
        // 镜面反射指数
        float spec = pow(max(dot(viewDir,reflectDir),0.0f),material.shininess);
        // 镜面光照
        vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;


        // spotlight
        float theta = dot(lightDir,normalize(-light.direction)); // 实际的光切角
        float epsilon  = (light.cutOff - light.outerCutOff);  // 给定的内光切和外光切的范围相减
        float intensty = clamp((theta - light.outerCutOff) / epsilon);  // 计算得出的内切外切聚光范围
        diffuse *= intensty;
        specular *= intensty;


        // 衰减光源
        float distance = length(light.position - FragPos);
        float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

        // 计算衰弱光源
        // 消除环境的衰减，否则在很远的距离处，由于 else 分支中的环境项，聚光灯内部的光会比外部更暗
        ambient *= attenuation;
        diffuse *= attenuation;
        specular  *= attenuation;
        vec3 result = ambient + diffuse + specular;
        FragColor = vec4(result,0);
}
```

- [x] 这样我们有了外切和内切的公式,就不需要在使用逻辑判断内切外切的范围了

  ```c++
  float outerCutOff = static_cast<float>(cos(qDegreesToRadians(17.5)));
  shaderProgramObject.setUniformValue("light.outerCutOff", outerCutOff);
  ```

  - 稍微对内外切光角实验一下，尝试创建一个更能符合你需求的聚光。这有点类似恐怖游戏中的灯光

## 练习:

- [x] 在片段着色器中计算漫反射光照夹角时，尝试改变向量的方向，观察效果，这会让你很清晰的发现它是如何影响光照的

  ```
  // 计算漫反射夹角
          float diff = max(dot(norm,lightDir),0.0f);
  ```

  - 当改变单独方向时,本来应该为锐角的夹角就会变成钝角，这时候漫反射光照计算的结果就会是0.0f 但镜面光照并不会被影响
  - 如果同时取反方向,不会有任何影响