投光物:

将光**投射**(Cast)到物体的光源叫做投光物(Light Caster)

## 定向光:

当假设光源处于**无限**远处时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。来自光源的每条光线就会近似于互相平行。

- [x] 我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。

- [x] 注意光源的方向（我们将方向定义为从光源出发的方向) 但我们需要一个从片段到光源的方向

  ```c++
  struct Light {
    vec3 direction;
  
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
  };
  // 将光的方向向量单位化 
      vec3 lightDir = normalize(-light.direction);
  shaderProgramObject.setUniformValue("light.direction",QVector3D(-0.2f, -1.0f, -0.3f));
  ```

  还有一点,我们如果将向量定义为四维向量,也就是vec4,那么有个很重要的一点，也就是之前所说的齐次坐标(w分量),就很重要了，

  - [x] 将w分量设置为1.0，这样变换和投影才能正确应用。

  - [x] 定义一个方向向量为`vec4`的时候，我们不想让位移有任何的效果（因为它仅仅代表的是方向），所以我们将w分量设置为0.0。

  - [x] 快速检测光照类型的方法

    ```c++
    if(lightVector.w == 0.0) 
      // 执行定向光照计算
    else if(lightVector.w == 1.0)
      // 根据光源的位置做光照计算
    ```

    

## 点光源:

- 定向光对于照亮整个场景的全局光源是非常棒的，
- 除了定向光之外我们也需要一些分散在场景中的点光源(Point Light)。
- 点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。
- 想象作为投光物的灯泡和火把，它们都是点光源。

值得注意的是 我们之前使用的都是一个类似于点光源的光源，但是我们模拟的是永远不会衰减的光线，这看起来光源特别强大，但正常情况下，我们都希望模拟的光源只是照亮光源附近的区域而不是整个场景

当然除了太阳这种平行光，默认他是不会衰减的

## 衰减

- [x] 随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)
- [x] 常数项Kc在所有的情况下都是1.0。一次项Kl为了覆盖更远的距离通常都很小，二次项Kq甚至更小实现,在我们的环境中，32到100的距离对大多数的光源都足够了。

| 距离 | 常数项 | 一次项 | 二次项   |
| :--- | :----- | :----- | :------- |
| 7    | 1.0    | 0.7    | 1.8      |
| 13   | 1.0    | 0.35   | 0.44     |
| 20   | 1.0    | 0.22   | 0.20     |
| 32   | 1.0    | 0.14   | 0.07     |
| 50   | 1.0    | 0.09   | 0.032    |
| 65   | 1.0    | 0.07   | 0.017    |
| 100  | 1.0    | 0.045  | 0.0075   |
| 160  | 1.0    | 0.027  | 0.0028   |
| 200  | 1.0    | 0.022  | 0.0019   |
| 325  | 1.0    | 0.014  | 0.0007   |
| 600  | 1.0    | 0.007  | 0.0002   |
| 3250 | 1.0    | 0.0014 | 0.000007 |

- [x] 实现衰减的常数项、一次项和二次项。

```
struct Light {
    vec3 position;  

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float constant;
    float linear;
    float quadratic;
};
```

- [x] 我们希望光源能够覆盖50的距离，所以我们会使用表格中对应的常数项、一次项和二次项：

```c++
        // 设置光源衰减系数
        shaderProgramObject.setUniformValue("light.constant",1.0f);
        shaderProgramObject.setUniformValue("light.linear",0.09f);
        shaderProgramObject.setUniformValue("light.quadratic",0.032f);
         // 计算距离
    float distance = length(light.position - FragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));
    ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;   
```

